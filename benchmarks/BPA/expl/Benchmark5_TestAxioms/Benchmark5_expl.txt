Now we wish to directly test whether the pointer axioms were correctly instantiated.

==============

Benchmark 5-1:

Axiom A_in states that for all pointers, their address value lies between 0 and A. This axiom is instantiated for all subexpressions of sort Pointer.

We declare a pointer, then attempt to claim it's address is out-of-range. This should be unsat.

Declare pointer pt.
Declare int addr

We Assert:
addr = base(block(pt)) + offset(pt)

addr < 0 OR addr > 512

==============

Benchmark 5-2:

Axiom A_<= states that pointer comparison between two pointers p and q is defined (and gives the expected result) exactly when both:
-p and q are not NULL, AND
-block(p) == block(q)

We therefore wish to test that:
(a) if the conditions are met, then we can't get a false result
(b) if any of the conditions are _not_ met, then we _can_ get a false result.

Declare pointers p and q.
For convenience, declare ints ap and aq.

We assert:
ap = base(block(p)) + offset(p)
aq = base(block(q)) + offset(q)

To test (a), we further assert:
ap != 0
aq != 0
block(p) == block(q)
ap <= aq
NOT (p <=p q)

This should be unsat.

To test (b), we try combinations of all of the above with one of the premises (i.e. everything except the last assertion) negated. All of these should be sat.

There is one more combination to test: If we negate ap <= aq, AND negate NOT(p <=p q), then we should in fact get unsat.

==============

Benchmark 5-3:

A_p states that a pointer with the same block and address as p must equal p. A_a states that the address of a created pointer is the address it was created with, provided that the address was valid. A_b states that the block of a created poitner is the block it was created with, provided that the address was valid.

We therefore wish to test these three axioms directly for an instantiated p.

Declare pointer p.
For convenience, declare Int a
For convenience, declare Int b
For convenience, assert b = Block(p).

Here are a few statements:
(1) a == b + offset(p).
(2) 0 <= a <= 512.

(3) (Create b a) == p.
(4) block(Create b a) == b.
(5) address(Create b a) == a

We can combine these in different combinations. We expect the following statements to be true:
(a): 1 implies 2.
(b): 1 implies 3.
(c): We can have ~1, 2 and 3 (Create is never under any direct obligation to _not_ equal anything.)

(d): 2 implies (4 and 5). (This doesn't use anything about p. This is just a direct statement of A_a and A_b together.)
(e): We can have ~2 and 4.
(f): We cannot have ~2 and 5.
(g): We _can_ have ~1 and 5.

==============















